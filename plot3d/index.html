<!DOCTYPE HTML>

<html>

<head>

<style>
html,body{
    margin:0;
    height:100%;
    overflow:hidden;
}

#disp{
    width:100%;
    height:100%;
}

</style>

<script type="text/Javascript">
"use strict";

var dim, disp, gl;
var vert, frag;
var prog;
var params={
    "scale":0.1,
    "depth":10,
    "mid":[0,0,0]
};

function createShader(gl, type, source) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
    return shader;
    }

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
    return program;
    }

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

function main(){
    requestAnimationFrame(main);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0,6);
}

function init(){
    disp = document.getElementById("disp");
    gl = disp.getContext("webgl2");
    gl.disable(gl.CULL_FACE);

    dim = [window.innerWidth, window.innerHeight];
    disp.width = dim[0];disp.height = dim[1];
    disp.style.width = dim[0]+"px";
    disp.style.height = dim[1]+"px";

    var vertSrc = document.getElementById("vert").innerHTML;
    vert = createShader(gl, gl.VERTEX_SHADER, vertSrc);
    var fragSrc = document.getElementById("frag").innerHTML;
    frag = createShader(gl, gl.FRAGMENT_SHADER, fragSrc);

    prog = createProgram(gl, vert, frag);

    var attribLoc = gl.getAttribLocation(prog, "a_position");
    var posBuff = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuff);
    var pos = [
        -1,-1,
        1,-1,
        -1,1,
        -1,1,
        1,-1,
        1,1
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);

    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.enableVertexAttribArray(attribLoc);
    gl.vertexAttribPointer(attribLoc, 2, gl.FLOAT, false, 0, 0);
    gl.viewport(0,0, dim[0], dim[1]);

    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

window.addEventListener("load", init);

</script>

<script type="text/glsl" id="vert">#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec4 a_position;

out float x0;
out float y0;

// all shaders have a main function
void main() {
    // gl_Position is a special variable a vertex shader
    // is responsible for setting
    gl_Position = a_position;
    x0 = a_position[0];
    y0 = a_position[1];
}

</script>
<script type="text/glsl" id="frag">#version 300 es
 
// fragment shaders don't have a default precision so we need
// to pick one. mediump is a good default. It means "medium precision"
precision mediump float;

in float x0;
in float y0;

float scale = 1.;
float aspect = 9./9.;
float depth = 2.;
vec3 mid = vec3(0.,0.,0.);
// we need to declare an output for the fragment shader
out vec4 outColor;

// https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
 
void main() {
    // Just set the output to a constant redish-purple
    float x = x0 * scale + mid[0];
    float y = y0 * scale / aspect + mid[1];
    //float z = x1 + y1;
    float z = pow(x, 2.0) + pow(y, 2.0);
    if (mod(z, 0.25) < 0.005) {
        outColor = vec4(0., 0., 0., 1.);
    } else {
        z = clamp((z-mid[2])/depth, 0., 5./6.);
        outColor = vec4(hsv2rgb(vec3(z, 1.0, 1.0)), 1);
    }
}
</script>

</head>

<body>

<canvas id="disp"></canvas>

</body>

</html>